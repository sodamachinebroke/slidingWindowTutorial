{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Goal of this documentation","text":"<p>I am learning how to document my progression with my own compression algorithm design.</p>"},{"location":"#binary-tree","title":"Binary tree","text":""},{"location":"#common-binary-tree","title":"common binary tree","text":"<ol> <li>This is done so that there is some base for comparison, but we're here so why not after all.</li> </ol>"},{"location":"#huffman-tree","title":"Huffman tree","text":"<ol> <li>This is an advanced form of a binary tree that takes the frequency of every byte, sorts them into a vector    and builds a binary tree based off that. New methods, contained in this class will only be the tree builder,    as it will receive a new kind of Node. This thing will supposedly build a more optimized binary tree, but    let's see how the compressed file will look.</li> </ol>"},{"location":"#example","title":"Example","text":"<ul> <li>We have the following file, as seen in a HEX-editor: <code>64 61 61 62 62 62 62 63 64 64</code>   dump: <code>daabbbbcdd</code></li> <li>Let's build a frequency vector (more or less a map, but due to it needing to be sortable, it will now be a   struct vector):</li> </ul> <pre><code>'d' =&gt; 3\n'a' =&gt; 2\n'b' =&gt; 4\n'c' =&gt; 1\n</code></pre> <p>Obviously the characters are only represented as characters. In reality they are 8bit long values.</p> <p>So after we are done with that, let's build a huffman tree:</p> <p></p> <p>Boom magic</p> <p>and this will be serialized as the following (according to my ideas):</p> <pre><code>[depth][code][value][code][value][code][value][code][value][encoded bitstream]\n[4][1][b][00][d][011][a][010][c][encoded bitstream]\n</code></pre> <p>Hopefully makes sense</p> <p>The decompressor will be able to build the tree out of it.</p>"},{"location":"#in-the-meantime-things-have-changed-so-these-are-now-deprecated","title":"In the meantime, things have changed, so these are now deprecated","text":""},{"location":"#length-prefix","title":"Length-prefix","text":"<p>i'll look into this</p>"},{"location":"#byte-stream","title":"Byte-stream","text":"<p>This will be more of an n-bit-stream. Basic idea is that codes are stored on equal length fields. From that, it will be easier to decompress the file. Example will be up soon.</p>"},{"location":"binaryTree/","title":"Binary Tree","text":""},{"location":"binaryTree/#this-class-is-used-for-building-the-binary-tree-that-stores-the-bytes","title":"This class is used for building the binary tree that stores the bytes","text":"<p>Main functions:</p>"},{"location":"binaryTree/#binarytree","title":"<code>BinaryTree()</code>","text":"<p><code>c++  BinaryTree::BinaryTree() : root(nullptr) {  }</code></p> <p>Constructor for the class, this is where <code>root</code> is being stored. <code>root</code> is the root of the b-tree. Self-explanatory.</p>"},{"location":"binaryTree/#buildtreeconst-stdvectoruint8_t-buffer","title":"<code>buildTree(const std::vector&lt;uint8_t&gt; &amp;buffer)</code>","text":"<p>This function serves as the backbone of the whole program.</p> <p>Asks for the buffer vector, which consists of bytes. It builds these bytes into a tree. Unfortunately not a very efficient tree. Returns the depth of said tree.</p>  buildTree <pre><code>uint8_t BinaryTree::buildTree(const std::vector&lt;uint8_t&gt; &amp;buffer) {\n    if (buffer.empty()) return 0;\n\n    root = new Node(buffer[0]);\n\n    if (buffer.size() == 1) return 1;\n\n    std::queue&lt;Node *&gt; nodeQueue;\n    nodeQueue.push(root);\n\n    size_t index = 1;\n    uint8_t depth = 0;\n\n    while (!nodeQueue.empty()) {\n        const size_t levelSize = nodeQueue.size();\n        ++depth;\n\n        for (size_t i = 0; i &lt; levelSize; ++i) {\n            Node *current = nodeQueue.front();\n            nodeQueue.pop();\n\n            if (index &lt; buffer.size()) {\n                current-&gt;left = new Node(buffer[index++]);\n                nodeQueue.push(current-&gt;left);\n            }\n            if (index &lt; buffer.size()) {\n                current-&gt;right = new Node(buffer[index++]);\n                nodeQueue.push(current-&gt;right);\n            }\n        }\n\n        if (depth == 255)break;\n    }\n    return depth;\n\n}\n</code></pre>"},{"location":"node/","title":"Node","text":"<p>Basic node storage class</p> <p>Has left and right Node pointers, which creates a recursive chain. In this recursive chain, every node has a value or <code>data</code>. This is used to store the binary value, aka a <code>byte</code> or in this case <code>uint8_t</code>.</p> Node <pre><code>class Node {\npublic:\n\n    Node *left;\n    Node *right;\n    uint8_t data;\n\n    explicit Node(uint8_t value) : data(value), left(nullptr), right(nullptr) {}\n\n};\n</code></pre>"},{"location":"recyclable/","title":"Recycle bin","text":"<p>These codes are technically still usable, but are not in use, so instead of deleting everything, i am resorting to sort of put them in a recycle bin instead. Might reuse later, might not. Either way, they will exist here.</p>"},{"location":"recyclable/#commons","title":"Commons","text":"<p>The old Commons class provides a string manipulation algorithm that splits a string into a vector of strings by a delimiter. The second function is used for creating a Huffman Tree and that one calculates the frequencies of words in a file i think.</p>"},{"location":"recyclable/#commonsh","title":"Commons.h","text":"<pre><code>#include &lt;vector&gt;\n#include &lt;string&gt;\n#include &lt;unordered_map&gt;\n#include &lt;cstdint&gt;\n\n#ifndef COMMONS_H\n#define COMMONS_H\n\nclass Commons {\npublic:\n\n    static size_t split(const std::string &amp;txt, std::vector&lt;std::string&gt; &amp;strs, char ch);\n\n    static std::unordered_map&lt;uint8_t, int&gt; calculateFrequencies(const std::string &amp;filename);\n\n};\n\n#endif //COMMONS_H\n</code></pre>"},{"location":"recyclable/#commonscpp","title":"Commons.cpp","text":"<pre><code>#include \"Commons.h\"\n\n#include &lt;string&gt;\n#include &lt;vector&gt;\n#include &lt;unordered_map&gt;\n#include &lt;iostream&gt;\n#include &lt;fstream&gt;\n#include &lt;cstdint&gt;\n\nsize_t Commons::split(const std::string &amp;txt, std::vector&lt;std::string&gt; &amp;strs, char ch) {\n\n    size_t pos = txt.find(ch);\n    size_t initialPos = 0;\n    strs.clear();\n\n    while (pos != std::string::npos) {\n        strs.push_back(txt.substr(initialPos, pos - initialPos));\n        initialPos = pos + 1;\n\n        pos = txt.find(ch, initialPos);\n    }\n\n    strs.push_back(txt.substr(initialPos, std::min(pos, txt.size()) - initialPos + 1));\n\n    return strs.size();\n\n}\n\nstd::unordered_map&lt;uint8_t, int&gt; Commons::calculateFrequencies(const std::string &amp;filename) {\n    std::ifstream file(filename, std::ios::binary);\n    std::unordered_map&lt;uint8_t, int&gt; frequencies;\n    uint8_t byte;\n\n    while (file.read(reinterpret_cast&lt;char *&gt;(&amp;byte), sizeof(byte))) {\n        frequencies[byte]++;\n    }\n\n    return frequencies;\n}\n</code></pre>"},{"location":"recyclable/#hashmap","title":"HashMap","text":"<p>This one uses a hash map to technically compress a string into smaller values. It works, it just has no meaningful function.</p>"},{"location":"recyclable/#hashmaph","title":"HashMap.h","text":"<pre><code>#ifndef HASHMAP_H\n#define HASHMAP_H\n\n#include &lt;string&gt;\n\nstruct WordInfo { // this can definitely be done without this\n    int code;\n    int distance;\n};\n\nclass HashMap {\npublic:\n    static std::vector&lt;WordInfo&gt; compressHashMap(const std::basic_string&lt;char&gt; &amp;INPUT);\n};\n\n#endif //HASHMAP_H\n</code></pre>"},{"location":"recyclable/#hashmapcpp","title":"HashMap.cpp","text":"<pre><code>#include &lt;vector&gt;\n#include &lt;unordered_map&gt;\n#include \"HashMap.h\"\n#include \"Commons.h\"\n\n\nstd::vector&lt;WordInfo&gt; HashMap::compressHashMap(const std::basic_string&lt;char&gt; &amp;INPUT) {\n    std::vector&lt;std::basic_string&lt;char&gt; &gt; raw_data;\n\n    Commons::split(INPUT, raw_data, ' ');\n\n    std::unordered_map&lt;std::basic_string&lt;char&gt;, int&gt; wordCodeMap;\n    std::vector&lt;WordInfo&gt; encodedData;\n\n    int currentCode = 1;\n    std::unordered_map&lt;std::basic_string&lt;char&gt;, int&gt; firstOccurrence;\n\n    for (int i = 0; i &lt; raw_data.size(); ++i) {\n        const std::basic_string&lt;char&gt; &amp;word = raw_data[i];\n        if (firstOccurrence.find(word) == firstOccurrence.end()) {\n            firstOccurrence[word] = i;\n            wordCodeMap[word] = currentCode++;\n\n            encodedData.push_back({wordCodeMap[word], 0});\n        } else {\n            int distance = i - firstOccurrence[word];\n            encodedData.push_back({wordCodeMap[word], distance});\n        }\n    }\n    return encodedData;\n}\n</code></pre>"},{"location":"recyclable/#buildfrequencytable","title":"buildFrequencyTable","text":"<p>This was in the main function, but it builds a frequency table for a Huffman Tree</p> <pre><code>std::unordered_map&lt;uint8_t, int&gt; buildFrequencyTable(const std::string &amp;inputFilename) {\n    std::ifstream inFile(inputFilename, std::ios::binary);\n    std::unordered_map&lt;uint8_t, int&gt; frequencies;\n    uint8_t byte;\n\n    while (inFile.read(reinterpret_cast&lt;char *&gt;(&amp;byte), sizeof(byte))) {\n        frequencies[byte]++;\n    }\n\n    return frequencies;\n}\n</code></pre>"},{"location":"recyclable/#findmaxentry","title":"findMaxEntry","text":"<p>This was also implemented in the main function and it finds the highest frequency entry. Used for creating a Huffman Tree once again.</p> <pre><code>std::pair&lt;uint8_t, int&gt; findMaxEntry(const std::unordered_map&lt;uint8_t, int&gt; &amp;frequencies) {\n    std::pair&lt;uint8_t, int&gt; maxEntry = std::make_pair(0, 0);\n\n    for (auto frequency: frequencies) {\n        if (frequency.second &gt; maxEntry.second) {\n            maxEntry = std::make_pair(frequency.first, frequency.second);\n        }\n    }\n\n    return maxEntry;\n}\n</code></pre>"}]}