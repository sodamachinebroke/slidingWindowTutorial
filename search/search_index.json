{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Goal of this documentation","text":"<p>I am learning how to document my progression with my own compression algorithm design.</p>"},{"location":"#binary-tree","title":"Binary tree","text":""},{"location":"#common-binary-tree","title":"common binary tree","text":"<ol> <li>This is done so that there is some base for comparison, but we're here so why not after all.</li> </ol>"},{"location":"#huffman-tree","title":"Huffman tree","text":"<ol> <li>This is an advanced form of a binary tree that takes the frequency of every byte, sorts them into a vector    and builds a binary tree based off that. New methods, contained in this class will only be the tree builder,    as it will receive a new kind of Node. This thing will supposedly build a more optimized binary tree, but    let's see how the compressed file will look.</li> </ol>"},{"location":"#example","title":"Example","text":"<ul> <li>We have the following file, as seen in a HEX-editor: <code>64 61 61 62 62 62 62 63 64 64</code>   dump: <code>daabbbbcdd</code></li> <li>Let's build a frequency vector (more or less a map, but due to it needing to be sortable, it will now be a   struct vector):</li> </ul> <pre><code>'d' =&gt; 3\n'a' =&gt; 2\n'b' =&gt; 4\n'c' =&gt; 1\n</code></pre> <p>Obviously the characters are only represented as characters. In reality they are 8bit long values.</p> <p>So after we are done with that, let's build a huffman tree:</p> <p></p> <p>Boom magic</p> <p>and this will be serialized as the following (according to my ideas):</p> <pre><code>[depth][code][value][code][value][code][value][code][value][encoded bitstream]\n[4][1][b][00][d][011][a][010][c][encoded bitstream]\n</code></pre> <p>Hopefully makes sense</p> <p>The decompressor will be able to build the tree out of it.</p>"},{"location":"#in-the-meantime-things-have-changed-so-these-are-now-deprecated","title":"In the meantime, things have changed, so these are now deprecated","text":""},{"location":"#length-prefix","title":"Length-prefix","text":"<p>i'll look into this</p>"},{"location":"#byte-stream","title":"Byte-stream","text":"<p>This will be more of an n-bit-stream. Basic idea is that codes are stored on equal length fields. From that, it will be easier to decompress the file. Example will be up soon.</p>"},{"location":"binaryTree/","title":"Binary Tree","text":""},{"location":"binaryTree/#this-class-is-used-for-building-the-binary-tree-that-stores-the-bytes","title":"This class is used for building the binary tree that stores the bytes","text":"<p>Main functions:</p>"},{"location":"binaryTree/#binarytree","title":"<code>BinaryTree()</code>","text":"<p><code>c++  BinaryTree::BinaryTree() : root(nullptr) {  }</code></p> <p>Constructor for the class, this is where <code>root</code> is being stored. <code>root</code> is the root of the b-tree. Self-explanatory.</p>"},{"location":"binaryTree/#buildtreeconst-stdvectoruint8_t-buffer","title":"<code>buildTree(const std::vector&lt;uint8_t&gt; &amp;buffer)</code>","text":"<p>This function serves as the backbone of the whole program.</p> <p>Asks for the buffer vector, which consists of bytes. It builds these bytes into a tree. Unfortunately not a very efficient tree. Returns the depth of said tree.</p>  buildTree <pre><code>uint8_t BinaryTree::buildTree(const std::vector&lt;uint8_t&gt; &amp;buffer) {\n    if (buffer.empty()) return 0;\n\n    root = new Node(buffer[0]);\n\n    if (buffer.size() == 1) return 1;\n\n    std::queue&lt;Node *&gt; nodeQueue;\n    nodeQueue.push(root);\n\n    size_t index = 1;\n    uint8_t depth = 0;\n\n    while (!nodeQueue.empty()) {\n        const size_t levelSize = nodeQueue.size();\n        ++depth;\n\n        for (size_t i = 0; i &lt; levelSize; ++i) {\n            Node *current = nodeQueue.front();\n            nodeQueue.pop();\n\n            if (index &lt; buffer.size()) {\n                current-&gt;left = new Node(buffer[index++]);\n                nodeQueue.push(current-&gt;left);\n            }\n            if (index &lt; buffer.size()) {\n                current-&gt;right = new Node(buffer[index++]);\n                nodeQueue.push(current-&gt;right);\n            }\n        }\n\n        if (depth == 255)break;\n    }\n    return depth;\n\n}\n</code></pre>"},{"location":"node/","title":"Node","text":"<p>Basic node storage class</p> <p>Has left and right Node pointers, which creates a recursive chain. In this recursive chain, every node has a value or <code>data</code>. This is used to store the binary value, aka a <code>byte</code> or in this case <code>uint8_t</code>.</p> Node <pre><code>class Node {\npublic:\n\n    Node *left;\n    Node *right;\n    uint8_t data;\n\n    explicit Node(uint8_t value) : data(value), left(nullptr), right(nullptr) {}\n\n};\n</code></pre>"},{"location":"readFromFile/","title":"This essentially is the second step in compression","text":"<p>It reads the file in chunks (preferably 2^x) and outputs a vector of numbers that later form the base for the binary tree's builder.</p>"},{"location":"readFromFile/#how-it-works","title":"How it works","text":"<p>We will go into detail about how it works, step by step. (Step =/= line, step = code block)</p> <pre><code>if (chunk_size &lt; 1) {\nstd::cerr &lt;&lt; \"chunk_size is less than 1\" &lt;&lt; std::endl;\nreturn 1;\n}\n</code></pre> <p>This checks whether the specified chunk size is actually more than 1, as a 0-length chunk doesn't exist.</p> <pre><code>if (!input.is_open()) {\n        std::cerr &lt;&lt; \"Unable to open file\" &lt;&lt; std::endl;\n        return 1;\n}\n</code></pre> <p>This checks whether there is an actual file.</p> <pre><code>std::vector&lt;char&gt; buffer(chunk_size);\nstd::unordered_set&lt;char&gt; unique_bytes;\n</code></pre> <p>It creates a <code>char</code> buffer and another <code>char</code> buffer. One of them stores the values read in a chunk and the other one will store the unique bytes in the buffer.</p> <pre><code>while (input.read(buffer.data(), static_cast&lt;std::streamsize&gt;(chunk_size)) || input.gcount() &gt; 0) {\n    auto bytes_read = static_cast&lt;std::size_t&gt;(input.gcount());\n\n    for (std::size_t i = 0; i &lt; bytes_read; ++i) {\n    unique_bytes.insert(buffer[i]);\n    }\n}\n</code></pre> <p>As long as there is still bytes to read, it will read them and create a <code>size_t</code> variable that stores the length it needs to input into the <code>unique_bytes</code> vector. Which it will later return with.</p> <pre><code>input.close();\n\n    std::vector&lt;uint8_t&gt; unique_vector(unique_bytes.begin(), unique_bytes.end());\n    std::sort(unique_vector.begin(), unique_vector.end());\n    std::cout &lt;&lt; \"Unique bytes in the file\" &lt;&lt; std::endl;\n\n    int i = 0;\n    for (uint8_t byte: unique_vector) {\n        std::cout &lt;&lt; std::hex &lt;&lt; std::setw(2) &lt;&lt; std::setfill('0')\n                  &lt;&lt; static_cast&lt;int&gt;( static_cast&lt;uint8_t&gt;(byte))\n                  &lt;&lt; \" \";\n        ++i;\n    }\n    uint8_t depth = tree.buildTree(unique_vector);\n    std::cout &lt;&lt; std::endl &lt;&lt; \"Size of unique_vector: \" &lt;&lt; unique_vector.size() &lt;&lt; std::endl &lt;&lt; \"Tree depth: \"\n              &lt;&lt; static_cast&lt;int&gt;(depth)\n              &lt;&lt; std::endl &lt;&lt; \"Tree built!\" &lt;&lt; std::endl;\n        return 0;\n\n}\n</code></pre> <p>Closes input file and then sorts the vector, prints it onto the screen, then builds a binary tree that is in the first argument of the function.</p>  readFromFile.h <pre><code>#ifndef READFILE_H\n#define READFILE_H\n\nclass ReadFile {\npublic:\nstatic int readFromFile(std::size_t chunk_size, const std::string &amp;file, BinaryTree &amp;tree);\n};\n\n#endif //READFILE_H\n</code></pre>  readFromFile.cpp <pre><code>int ReadFile::readFromFile(const std::size_t chunk_size, const std::string &amp;file, BinaryTree &amp;tree) {\nif (chunk_size &lt; 1) {\nstd::cerr &lt;&lt; \"chunk_size is less than 1\" &lt;&lt; std::endl;\nreturn 1;\n}\n\n    std::vector&lt;char&gt; buffer(chunk_size); // Buffer for reading chunks\n    std::unordered_set&lt;char&gt; unique_bytes;\n\n    // Open file in binary mode\n    std::ifstream input(file, std::ios::binary);\n    if (!input.is_open()) {\n        std::cerr &lt;&lt; \"Unable to open file\" &lt;&lt; std::endl;\n        return 1;\n    }\n\n    // Read file in chunks\n    while (input.read(buffer.data(), static_cast&lt;std::streamsize&gt;(chunk_size)) || input.gcount() &gt; 0) {\n        auto bytes_read = static_cast&lt;std::size_t&gt;(input.gcount()); // Number of bytes read in the last chunk\n\n        for (std::size_t i = 0; i &lt; bytes_read; ++i) {\n            unique_bytes.insert(buffer[i]);\n        }\n    }\n\n    input.close();\n\n    std::vector&lt;uint8_t&gt; unique_vector(unique_bytes.begin(), unique_bytes.end());\n    std::sort(unique_vector.begin(), unique_vector.end());\n    std::cout &lt;&lt; \"Unique bytes in the file\" &lt;&lt; std::endl;\n\n    int i = 0;\n    for (uint8_t byte: unique_vector) {\n        std::cout &lt;&lt; std::hex &lt;&lt; std::setw(2) &lt;&lt; std::setfill('0')\n                  &lt;&lt; static_cast&lt;int&gt;( static_cast&lt;uint8_t&gt;(byte))\n                  &lt;&lt; \" \";\n        ++i;\n    }\n    uint8_t depth = tree.buildTree(unique_vector);\n    std::cout &lt;&lt; std::endl &lt;&lt; \"Size of unique_vector: \" &lt;&lt; unique_vector.size() &lt;&lt; std::endl &lt;&lt; \"Tree depth: \"\n              &lt;&lt; static_cast&lt;int&gt;(depth)\n              &lt;&lt; std::endl &lt;&lt; \"Tree built!\" &lt;&lt; std::endl;\n\n    return 0;\n\n}\n</code></pre>"},{"location":"recyclable/","title":"Recycle bin","text":"<p>These codes are technically still usable, but are not in use, so instead of deleting everything, i am resorting to sort of put them in a recycle bin instead. Might reuse later, might not. Either way, they will exist here.</p>"},{"location":"recyclable/#commons","title":"Commons","text":"<p>The old Commons class provides a string manipulation algorithm that splits a string into a vector of strings by a delimiter. The second function is used for creating a Huffman Tree and that one calculates the frequencies of words in a file i think.</p>"},{"location":"recyclable/#commonsh","title":"Commons.h","text":"<pre><code>#include &lt;vector&gt;\n#include &lt;string&gt;\n#include &lt;unordered_map&gt;\n#include &lt;cstdint&gt;\n\n#ifndef COMMONS_H\n#define COMMONS_H\n\nclass Commons {\npublic:\n\n    static size_t split(const std::string &amp;txt, std::vector&lt;std::string&gt; &amp;strs, char ch);\n\n    static std::unordered_map&lt;uint8_t, int&gt; calculateFrequencies(const std::string &amp;filename);\n\n};\n\n#endif //COMMONS_H\n</code></pre>"},{"location":"recyclable/#commonscpp","title":"Commons.cpp","text":"<pre><code>#include \"Commons.h\"\n\n#include &lt;string&gt;\n#include &lt;vector&gt;\n#include &lt;unordered_map&gt;\n#include &lt;iostream&gt;\n#include &lt;fstream&gt;\n#include &lt;cstdint&gt;\n\nsize_t Commons::split(const std::string &amp;txt, std::vector&lt;std::string&gt; &amp;strs, char ch) {\n\n    size_t pos = txt.find(ch);\n    size_t initialPos = 0;\n    strs.clear();\n\n    while (pos != std::string::npos) {\n        strs.push_back(txt.substr(initialPos, pos - initialPos));\n        initialPos = pos + 1;\n\n        pos = txt.find(ch, initialPos);\n    }\n\n    strs.push_back(txt.substr(initialPos, std::min(pos, txt.size()) - initialPos + 1));\n\n    return strs.size();\n\n}\n\nstd::unordered_map&lt;uint8_t, int&gt; Commons::calculateFrequencies(const std::string &amp;filename) {\n    std::ifstream file(filename, std::ios::binary);\n    std::unordered_map&lt;uint8_t, int&gt; frequencies;\n    uint8_t byte;\n\n    while (file.read(reinterpret_cast&lt;char *&gt;(&amp;byte), sizeof(byte))) {\n        frequencies[byte]++;\n    }\n\n    return frequencies;\n}\n</code></pre>"},{"location":"recyclable/#hashmap","title":"HashMap","text":"<p>This one uses a hash map to technically compress a string into smaller values. It works, it just has no meaningful function.</p>"},{"location":"recyclable/#hashmaph","title":"HashMap.h","text":"<pre><code>#ifndef HASHMAP_H\n#define HASHMAP_H\n\n#include &lt;string&gt;\n\nstruct WordInfo { // this can definitely be done without this\n    int code;\n    int distance;\n};\n\nclass HashMap {\npublic:\n    static std::vector&lt;WordInfo&gt; compressHashMap(const std::basic_string&lt;char&gt; &amp;INPUT);\n};\n\n#endif //HASHMAP_H\n</code></pre>"},{"location":"recyclable/#hashmapcpp","title":"HashMap.cpp","text":"<pre><code>#include &lt;vector&gt;\n#include &lt;unordered_map&gt;\n#include \"HashMap.h\"\n#include \"Commons.h\"\n\n\nstd::vector&lt;WordInfo&gt; HashMap::compressHashMap(const std::basic_string&lt;char&gt; &amp;INPUT) {\n    std::vector&lt;std::basic_string&lt;char&gt; &gt; raw_data;\n\n    Commons::split(INPUT, raw_data, ' ');\n\n    std::unordered_map&lt;std::basic_string&lt;char&gt;, int&gt; wordCodeMap;\n    std::vector&lt;WordInfo&gt; encodedData;\n\n    int currentCode = 1;\n    std::unordered_map&lt;std::basic_string&lt;char&gt;, int&gt; firstOccurrence;\n\n    for (int i = 0; i &lt; raw_data.size(); ++i) {\n        const std::basic_string&lt;char&gt; &amp;word = raw_data[i];\n        if (firstOccurrence.find(word) == firstOccurrence.end()) {\n            firstOccurrence[word] = i;\n            wordCodeMap[word] = currentCode++;\n\n            encodedData.push_back({wordCodeMap[word], 0});\n        } else {\n            int distance = i - firstOccurrence[word];\n            encodedData.push_back({wordCodeMap[word], distance});\n        }\n    }\n    return encodedData;\n}\n</code></pre>"},{"location":"recyclable/#buildfrequencytable","title":"buildFrequencyTable","text":"<p>This was in the main function, but it builds a frequency table for a Huffman Tree</p> <pre><code>std::unordered_map&lt;uint8_t, int&gt; buildFrequencyTable(const std::string &amp;inputFilename) {\n    std::ifstream inFile(inputFilename, std::ios::binary);\n    std::unordered_map&lt;uint8_t, int&gt; frequencies;\n    uint8_t byte;\n\n    while (inFile.read(reinterpret_cast&lt;char *&gt;(&amp;byte), sizeof(byte))) {\n        frequencies[byte]++;\n    }\n\n    return frequencies;\n}\n</code></pre>"},{"location":"recyclable/#findmaxentry","title":"findMaxEntry","text":"<p>This was also implemented in the main function and it finds the highest frequency entry. Used for creating a Huffman Tree once again.</p> <pre><code>std::pair&lt;uint8_t, int&gt; findMaxEntry(const std::unordered_map&lt;uint8_t, int&gt; &amp;frequencies) {\n    std::pair&lt;uint8_t, int&gt; maxEntry = std::make_pair(0, 0);\n\n    for (auto frequency: frequencies) {\n        if (frequency.second &gt; maxEntry.second) {\n            maxEntry = std::make_pair(frequency.first, frequency.second);\n        }\n    }\n\n    return maxEntry;\n}\n</code></pre> <pre><code>#include &lt;iostream&gt;\n#include &lt;vector&gt;\n#include &lt;fstream&gt;\n#include &lt;cstdint&gt;\n#include &lt;iomanip&gt;\n\nstd::vector&lt;uint8_t&gt; readBinaryFile(const std::string &amp;filename) {\nstd::ifstream file(filename, std::ios::binary);\nif (!file) throw std::runtime_error(\"Error opening file: \" + filename);\nreturn std::vector&lt;uint8_t&gt;(std::istreambuf_iterator&lt;char&gt;(file), {});\n}\n\nvoid runLengthEncode(const std::vector&lt;uint8_t&gt; &amp;data, const std::string &amp;filename) {\nstd::ofstream file(filename, std::ios::binary);\nif (!file) return;\n\nstd::vector&lt;std::pair&lt;uint8_t, uint32_t&gt;&gt; encodedData;\n\nfor (size_t i = 0; i &lt; data.size();) {\nuint8_t value = data[i];\nuint32_t count = 1;\n\nwhile (i + count &lt; data.size() &amp;&amp; data[i + count] == value) ++count;\n\nencodedData.emplace_back(value, count);\ni += count;\n}\n\nfor (const auto &amp;[value, count]: encodedData) {\nfile.write(reinterpret_cast&lt;const char *&gt;(&amp;value), sizeof(uint8_t));\nfile.write(reinterpret_cast&lt;const char *&gt;(&amp;count), sizeof(uint32_t));\n}\n\nfile.close();\n\nstd::cout &lt;&lt; \"Data written to: \" &lt;&lt; filename &lt;&lt; std::endl;\n}\n\nvoid runLengthDecode(const std::string &amp;filename, std::vector&lt;uint8_t&gt; &amp;decodedData) {\nstd::ifstream file(filename, std::ios::binary);\nif (!file) return;\ndecodedData.clear();\n\nuint8_t value;\nuint32_t count;\n\nwhile (file.read(reinterpret_cast&lt;char *&gt;(&amp;value), sizeof(uint8_t)) &amp;&amp;\nfile.read(reinterpret_cast&lt;char *&gt;(&amp;count), sizeof(uint32_t))) {\nfor (uint32_t i = 0; i &lt; count; ++i) decodedData.push_back(value);\n}\n\nfile.close();\nstd::cout &lt;&lt; \"Run-Length Decoded data read from \" &lt;&lt; filename &lt;&lt; std::endl;\n}\n</code></pre> <pre><code> const std::string infile = \"../public/movie.mp4\";\nconst std::string outfile = \"../public/rle_movie.bin\";\ntry {\n\nstd::vector&lt;uint8_t&gt; data = readBinaryFile(infile);\nrunLengthEncode(data, outfile);\n\n// std::vector&lt;uint8_t&gt; decodedData;\n//runLengthDecode(outfile, decodedData);\n\n// Verify the result\n/*std::cout &lt;&lt; \"Original Data: \";\nfor (uint8_t value: data) {\n    std::cout &lt;&lt; std::hex &lt;&lt; std::setw(2) &lt;&lt; std::setfill('0') &lt;&lt; (int) value &lt;&lt; \" \";\n}\nstd::cout &lt;&lt; \"\\nDecoded Data: \";\nfor (uint8_t value: decodedData) {\n    std::cout &lt;&lt; std::hex &lt;&lt; std::setw(2) &lt;&lt; std::setfill('0') &lt;&lt; (int) value &lt;&lt; \" \";\n}\nstd::cout &lt;&lt; std::endl;*/\n} catch (const std::exception &amp;e) {\nstd::cerr &lt;&lt; \"Error: \" &lt;&lt; e.what() &lt;&lt; std::endl;\n\n}\n</code></pre>"},{"location":"recyclable/#this-might-be-recyclable","title":"This might be recyclable","text":"<p>It builds a binary tree out of the code, but does it wrong. I decided to ditch the binary tree and use hash chains instead.</p> <pre><code>#include \"src/ReadFile.h\"\n//BinaryTree tree;\n//ReadFile::readFromFile(256, \"../public/input6.bin\", tree);\n#include &lt;iostream&gt;\n#include &lt;fstream&gt;\n#include &lt;vector&gt;\n#include &lt;unordered_map&gt;\n#include &lt;queue&gt;\n#include &lt;bitset&gt;\n#include &lt;memory&gt;\n#include &lt;stdexcept&gt;\n#include &lt;cstdint&gt;\n\nstruct HuffmanNode {\n    uint8_t value;\n    uint64_t frequency;\n    std::shared_ptr&lt;HuffmanNode&gt; left, right;\n\n    // Constructor for internal nodes\n    explicit HuffmanNode(uint64_t freq, std::shared_ptr&lt;HuffmanNode&gt; l = nullptr,\n                         std::shared_ptr&lt;HuffmanNode&gt; r = nullptr)\n            : value(0), frequency(freq), left(std::move(l)), right(std::move(r)) {}\n\n    // Constructor for leaf nodes\n    HuffmanNode(uint8_t val, uint64_t freq) : value(val), frequency(freq) {}\n\n    // Compare nodes by frequency (priority queue)\n    bool operator&gt;(const HuffmanNode &amp;other) const {\n        return frequency &gt; other.frequency;\n    }\n};\n\n// Recursive function to build the Huffman codes\nvoid buildHuffmanCodes(const std::shared_ptr&lt;HuffmanNode&gt; &amp;node, const std::string &amp;code,\n                       std::unordered_map&lt;uint8_t, std::string&gt; &amp;huffmanCodes) {\n    if (!node-&gt;left &amp;&amp; !node-&gt;right) {\n        huffmanCodes[node-&gt;value] = code; // Leaf node\n        return;\n    }\n\n    if (node-&gt;left) buildHuffmanCodes(node-&gt;left, code + \"0\", huffmanCodes);\n    if (node-&gt;right) buildHuffmanCodes(node-&gt;right, code + \"1\", huffmanCodes);\n}\n\n// Serialize the Huffman tree into a file\nvoid serializeTree(const std::shared_ptr&lt;HuffmanNode&gt; &amp;node, std::ostream &amp;output) {\n    if (!node) return;\n\n    if (!node-&gt;left &amp;&amp; !node-&gt;right) {\n        // Write marker '1' and the leaf symbol\n        char leafMarker = 0b1; // Binary marker for a leaf\n        output.put(leafMarker);\n        output.put(node-&gt;value); // Write symbol as-is\n    } else {\n        // Write marker '0' for internal node\n        char internalMarker = 0b0;\n        output.put(internalMarker);\n        serializeTree(node-&gt;left, output);\n        serializeTree(node-&gt;right, output);\n    }\n}\n\n\n// Deserialize the Huffman tree from a file\nstd::shared_ptr&lt;HuffmanNode&gt; deserializeTree(std::istream &amp;input) {\n    char marker;\n    if (!input.get(marker)) return nullptr;\n\n    if (marker &amp; 0b1) {\n        // Leaf node: Read the value\n        char value;\n        input.get(value);\n        return std::make_shared&lt;HuffmanNode&gt;(value);\n    } else {\n        // Internal node\n        auto left = deserializeTree(input);\n        auto right = deserializeTree(input);\n        return std::make_shared&lt;HuffmanNode&gt;(0, left, right); // Internal nodes don't store values\n    }\n}\n\n\n// Huffman encode the input data\nvoid huffmanEncode(const std::string &amp;inputFilename, const std::string &amp;outputFilename) {\n    // Read the input file\n    std::ifstream inputFile(inputFilename, std::ios::binary);\n    if (!inputFile) {\n        throw std::runtime_error(\"Error opening input file.\");\n    }\n\n    // Count byte frequencies\n    std::unordered_map&lt;uint8_t, uint64_t&gt; frequencies;\n    std::vector&lt;uint8_t&gt; data(std::istreambuf_iterator&lt;char&gt;(inputFile), {});\n    for (uint8_t byte: data) {\n        frequencies[byte]++;\n    }\n\n    // Build priority queue (min-heap) of Huffman nodes\n    auto cmp = [](const std::shared_ptr&lt;HuffmanNode&gt; &amp;a, const std::shared_ptr&lt;HuffmanNode&gt; &amp;b) { return *a &gt; *b; };\n    std::priority_queue&lt;std::shared_ptr&lt;HuffmanNode&gt;, std::vector&lt;std::shared_ptr&lt;HuffmanNode&gt;&gt;, decltype(cmp)&gt; pq(cmp);\n\n    for (const auto &amp;[byte, freq]: frequencies) {\n        pq.push(std::make_shared&lt;HuffmanNode&gt;(byte, freq));\n    }\n\n    // Build the Huffman tree\n    while (pq.size() &gt; 1) {\n        auto left = pq.top();\n        pq.pop();\n        auto right = pq.top();\n        pq.pop();\n        pq.push(std::make_shared&lt;HuffmanNode&gt;(left-&gt;frequency + right-&gt;frequency, left, right));\n    }\n\n    auto root = pq.top();\n\n    // Generate Huffman codes\n    std::unordered_map&lt;uint8_t, std::string&gt; huffmanCodes;\n    buildHuffmanCodes(root, \"\", huffmanCodes);\n\n    // Serialize the Huffman tree and encoded data\n    std::ofstream outputFile(outputFilename, std::ios::binary);\n    if (!outputFile) {\n        throw std::runtime_error(\"Error opening output file.\");\n    }\n\n    serializeTree(root, outputFile);\n\n    // Write encoded data\n    std::string bitString;\n    for (uint8_t byte: data) {\n        bitString += huffmanCodes[byte];\n    }\n\n    // Pad bitString to a multiple of 8\n    while (bitString.size() % 8 != 0) {\n        bitString += '0';\n    }\n\n    for (size_t i = 0; i &lt; bitString.size(); i += 8) {\n        uint8_t byte = std::bitset&lt;8&gt;(bitString.substr(i, 8)).to_ulong();\n        outputFile.put(byte);\n    }\n\n    outputFile.close();\n    std::cout &lt;&lt; \"File successfully Huffman-encoded: \" &lt;&lt; outputFilename &lt;&lt; std::endl;\n}\n\n// Huffman decode the input file\nvoid huffmanDecode(const std::string &amp;inputFilename, const std::string &amp;outputFilename) {\n    std::ifstream inputFile(inputFilename, std::ios::binary);\n    if (!inputFile) {\n        throw std::runtime_error(\"Error opening input file.\");\n    }\n\n    // Deserialize the Huffman tree\n    auto root = deserializeTree(inputFile);\n\n    // Read encoded data\n    std::vector&lt;uint8_t&gt; encodedData(std::istreambuf_iterator&lt;char&gt;(inputFile), {});\n    std::string bitString;\n    for (uint8_t byte: encodedData) {\n        bitString += std::bitset&lt;8&gt;(byte).to_string();\n    }\n\n    // Decode the data\n    std::ofstream outputFile(outputFilename, std::ios::binary | std::ios::trunc);\n    if (!outputFile) {\n        throw std::runtime_error(\"Error opening output file.\");\n    }\n\n    auto node = root;\n    for (char bit: bitString) {\n        node = (bit == '0') ? node-&gt;left : node-&gt;right;\n\n        if (!node-&gt;left &amp;&amp; !node-&gt;right) {\n            outputFile.put(node-&gt;value);\n            node = root;\n        }\n    }\n\n    outputFile.close();\n    std::cout &lt;&lt; \"File successfully Huffman-decoded: \" &lt;&lt; outputFilename &lt;&lt; std::endl;\n}\n\nint main() {\n    const std::string inputFilename = \"../public/input5.bin\";\n    const std::string encodedFilename = \"../public/temp/encoded.huff\";\n    const std::string decodedFilename = \"../public/output/decoded.bin\";\n\n    try {\n        huffmanEncode(inputFilename, encodedFilename);\n        huffmanDecode(encodedFilename, decodedFilename);\n    } catch (const std::exception &amp;ex) {\n        std::cerr &lt;&lt; \"Error: \" &lt;&lt; ex.what() &lt;&lt; std::endl;\n    }\n\n    return 0;\n}\n</code></pre>"}]}