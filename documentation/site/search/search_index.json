{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Goal of this documentation","text":"<p>I am learning how to document my progression with my own compression algorithm design.</p>"},{"location":"#key-functions","title":"Key functions:","text":"<ul> <li>Split</li> </ul> <pre><code>size_t split(const std::string &amp;txt, std::vector&lt;std::string&gt; &amp;strs, char ch);\n</code></pre> <p>Excuse me for pooping all over the place, but here we go</p> <p>So the basic idea is that there will be a compressor that creates the smallest possible files. The execution is going to be done in a number of ways.</p> <p>I'll list the execution methods quickly:</p>"},{"location":"#binary-tree","title":"Binary tree","text":""},{"location":"#common-binary-tree","title":"common binary tree","text":"<ol> <li>This is done so that there is some base for comparison, but we're here so why not after all.</li> </ol>"},{"location":"#huffman-tree","title":"Huffman tree","text":"<ol> <li>This is an advanced form of a binary tree that takes the frequency of every byte, sorts them into a vector    and builds a binary tree based off that. New methods, contained in this class will only be the tree builder,    as it will receive a new kind of Node. This thing will supposedly build a more optimized binary tree, but    let's see how the compressed file will look.</li> </ol>"},{"location":"#example","title":"Example","text":"<ul> <li>We have the following file, as seen in a HEX-editor: <code>64 61 61 62 62 62 62 63 64 64</code>   dump: <code>daabbbbcdd</code></li> <li>Let's build a frequency vector (more or less a map, but due to it needing to be sortable, it will now be a   struct vector):</li> </ul> <pre><code>'d' =&gt; 3\n'a' =&gt; 2\n'b' =&gt; 4\n'c' =&gt; 1\n</code></pre> <p>Obviously the characters are only represented as characters. In reality they are 8bit long values.</p> <p>So after we are done with that, let's build a huffman tree:</p> <p></p> <p>Boom magic</p> <p>and this will be serialized as the following (according to my ideas):</p> <pre><code>[depth][code][value][code][value][code][value][code][value][encoded bitstream]\n[4][1][b][00][d][011][a][010][c][encoded bitstream]\n</code></pre> <p>Hopefully makes sense</p> <p>The decompressor will be able to build the tree out of it.</p>"},{"location":"#length-prefix","title":"Length-prefix","text":"<p>i'll look into this</p>"},{"location":"#byte-stream","title":"Byte-stream","text":"<p>This will be more of an n-bit-stream. Basic idea is that codes are stored on equal length fields. From that, it will be easier to decompress the file. Example will be up soon.</p>"},{"location":"commons/","title":"Commons","text":"Header <pre><code>#include &lt;vector&gt;\n#include &lt;string&gt;\n\n#ifndef COMMONS_H\n#define COMMONS_H\n\n\nclass Commons {\npublic:\n\n    static size_t split(const std::string &amp;txt, std::vector&lt;std::string&gt; &amp;strs, char ch);\n};\n\n#endif //COMMONS_H\n</code></pre> Source file <pre><code>#include \"header/commons.h\"\n\n#include &lt;string&gt;\n#include &lt;vector&gt;\n\nsize_t Commons::split(const std::string &amp;txt, std::vector&lt;std::string&gt; &amp;strs, char ch) {\n\n    size_t pos = txt.find(ch);\n    size_t initialPos = 0;\n    strs.clear();\n\n    while (pos != std::string::npos) {\n        strs.push_back(txt.substr(initialPos, pos - initialPos));\n        initialPos = pos + 1;\n\n        pos = txt.find(ch, initialPos);\n    }\n\n    strs.push_back(txt.substr(initialPos, std::min(pos, txt.size()) - initialPos + 1));\n\n    return strs.size();\n\n}\n</code></pre>"},{"location":"commons/#split","title":"Split","text":"Full source code <pre><code>size_t Commons::split(const std::string &amp;txt, std::vector&lt;std::string&gt; &amp;strs, char ch) {\n\n    size_t pos = txt.find(ch);\n    size_t initialPos = 0;\n    strs.clear();\n\n    while (pos != std::string::npos) {\n        strs.push_back(txt.substr(initialPos, pos - initialPos));\n        initialPos = pos + 1;\n\n        pos = txt.find(ch, initialPos);\n    }\n\n    strs.push_back(txt.substr(initialPos, std::min(pos, txt.size()) - initialPos + 1));\n\n    return strs.size();\n\n}\n</code></pre> <p>This function splits a full string into a vector, so it's easier to detect duplicates. It also doesn't really work with end of sentence marks, but that's not really too important. The important part is to split the string somehow.</p>"},{"location":"commons/#3-inputs","title":"3 inputs:","text":"<ul> <li><code>const std::string &amp;txt</code> - Input text</li> <li><code>std::vector&lt;std::string&gt; &amp;strs</code> - Output vector</li> <li><code>char ch</code> - Delimiter</li> <li>Return value is <code>size_t</code>, which means it returns the length of the output vector</li> </ul>"},{"location":"commons/#initializing-values","title":"Initializing values","text":"<pre><code>size_t pos = txt.find(ch);\nsize_t initialPos = 0;\nstrs.clear();\n</code></pre>"},{"location":"commons/#everything-after-this-is-bullshit","title":"Everything after this is bullshit","text":""},{"location":"commons/#copying-everything-to-the-vector","title":"Copying everything to the vector","text":"<pre><code>while (pos != std::string::npos) {\n        strs.push_back(txt.substr(initialPos, pos - initialPos));\n        initialPos = pos + 1;\n\n        pos = txt.find(ch, initialPos);\n    }\n</code></pre> <p>It runs until the end of the string (<code>std::string::npos</code>) and it adds the substring to the end of the output vector. Then moves \"initialPos\" to after \"pos\". Then sets \"pos\" to find the next delimiter from \"initialPos\".</p>"},{"location":"commons/#finding-duplicates","title":"Finding duplicates","text":"<pre><code>strs.push_back(txt.substr(initialPos, std::min(pos, txt.size()) - initialPos + 1));\n</code></pre>"}]}